/**
 * Execute a sequence of operations.
 * Main outer API for executing expressions.
 * @public
 * @example
 *  execute(
 *    create('foo'),
 *    delete('bar')
 *  )
 * @private
 * @param {Operations} operations - Operations to be performed.
 * @returns {Promise}
 */
export function execute(...operations: Operations): Promise<any>;
/**
 * alias for "fn()"
 * @function
 * @param {Function} func is the function
 * @returns {Operation}
 */
export function alterState(func: Function): Operation;
/**
 * Creates a custom step (or operation) for more flexible job writing.
 * @public
 * @function
 * @example
 * fn(state => {
 *   // do some things to state
 *   return state;
 * });
 * @param {Function} func is the function
 * @returns {Operation}
 */
export function fn(func: Function): Operation;
/**
 * A custom operation that will only execute the function if the condition returns true
 * @public
 * @function
 * @example
 * fnIf((state) => state?.data?.name, get("https://example.com"));
 * @param {Boolean} condition - The condition that returns true
 * @param {Operation} operation - The operation needed to be executed.
 * @returns {Operation}
 */
export function fnIf(condition: boolean, operation: Operation): Operation;
/**
 * Picks out a single value from a JSON object.
 * If a JSONPath returns more than one value for the reference, the first
 * item will be returned.
 * @public
 * @function
 * @example
 * jsonValue({ a:1 }, 'a')
 * @param {object} obj - A valid JSON object.
 * @param {String} path - JSONPath referencing a point in given JSON object.
 * @returns {Operation}
 */
export function jsonValue(obj: object, path: string): Operation;
/**
 * Picks out a single value from source data.
 * If a JSONPath returns more than one value for the reference, the first
 * item will be returned.
 * @public
 * @function
 * @example
 * sourceValue('$.key')
 * @param {String} path - JSONPath referencing a point in `state`.
 * @returns {Operation}
 */
export function sourceValue(path: string): Operation;
/**
 * Picks out a value from source data.
 * Will return whatever JSONPath returns, which will always be an array.
 * If you need a single value use `sourceValue` instead.
 * @public
 * @function
 * @example
 * source('$.key')
 * @param {String} path - JSONPath referencing a point in `state`.
 * @returns {Array.<String|Object>}
 */
export function source(path: string): Array<string | any>;
/**
 * Ensures a path points at the data.
 * @public
 * @function
 * @example
 * dataPath('key')
 * @param {string} path - JSONPath referencing a point in `data`.
 * @returns {string}
 */
export function dataPath(path: string): string;
/**
 * Picks out a single value from the source data object‚Äîusually `state.data`.
 * If a JSONPath returns more than one value for the reference, the first
 * item will be returned.
 * @public
 * @function
 * @example
 * dataValue('key')
 * @param {String} path - JSONPath referencing a point in `data`.
 * @returns {Operation}
 */
export function dataValue(path: string): Operation;
/**
 * Ensures a path points at references.
 * @public
 * @function
 * @example
 * referencePath('key')
 * @param {string} path - JSONPath referencing a point in `references`.
 * @returns {string}
 */
export function referencePath(path: string): string;
/**
 * Picks out the last reference value from source data.
 * @public
 * @function
 * @example
 * lastReferenceValue('key')
 * @param {String} path - JSONPath referencing a point in `references`.
 * @returns {Operation}
 */
export function lastReferenceValue(path: string): Operation;
/**
 * Simple switcher allowing other expressions to use either a JSONPath or
 * object literals as a data source.
 * - JSONPath referencing a point in `state`
 * - Object Literal of the data itself.
 * - Function to be called with state.
 * @public
 * @function
 * @example
 * asData('$.key'| key | callback)
 * @param {String|object|function} data
 * @param {object} state - The current state.
 * @returns {array}
 */
export function asData(data: string | object | Function, state: object): any[];
/**
 * Iterates over an array of items and invokes an operation upon each one, where the state
 * object is _scoped_ so that state.data is the item under iteration.
 * The rest of the state object is untouched and can be referenced as usual.
 * You can pass an array directly, or use lazy state or a JSONPath string to
 * reference a slice of state.
 * @public
 * @function
 * @example <caption>Using lazy state ($) to iterate over items in state.data and pass each into an "insert" operation</caption>
 * each(
 *   $.data,
 *   // Inside the callback operation, `$.data` is scoped to the item under iteration
 *   insert("patient", {
 *     patient_name: $.data.properties.case_name,
 *     patient_id: $.data.case_id,
 *   })
 * );
 * @example <caption>Iterate over items in state.data and pass each one into an "insert" operation</caption>
 * each(
 *   $.data,
 *   insert("patient", (state) => ({
 *     patient_id: state.data.case_id,
 *     ...state.data
 *   }))
 * );
 * @example <caption>Using JSON path to iterate over items in state.data and pass each one into an "insert" operation</caption>
 * each(
 *   "$.data[*]",
 *   insert("patient", (state) => ({
 *     patient_name: state.data.properties.case_name,
 *     patient_id: state.data.case_id,
 *   }))
 * );
 * @param {DataSource} dataSource - JSONPath referencing a point in `state`.
 * @param {Operation} operation - The operation needed to be repeated.
 * @returns {Operation}
 */
export function each(dataSource: DataSource, operation: Operation): Operation;
/**
 * Combines two operations into one
 * @public
 * @function
 * @example
 * combine(
 *   create('foo'),
 *   delete('bar')
 * )
 * @param {Operations} operations - Operations to be performed.
 * @returns {Operation}
 */
export function combine(...operations: Operations): Operation;
/**
 * Adds data from a target object
 * @public
 * @function
 * @example
 * join('$.key','$.data','newKey')
 * @param {String} targetPath - Target path
 * @param {String} sourcePath - Source path
 * @param {String} targetKey - Target Key
 * @returns {Operation}
 */
export function join(targetPath: string, sourcePath: string, targetKey: string): Operation;
/**
 * Returns a key, value pair in an array.
 * @public
 * @function
 * @example
 * field('destination_field_name__c', 'value')
 * @param {string} key - Name of the field
 * @param {Value} value - The value itself or a sourceable operation.
 * @returns {Field}
 */
export function field(key: string, value: Value): Field;
/**
 * Zips key value pairs into an object.
 * @public
 * @function
 * @example
 *  fields(list_of_fields)
 * @param {Fields} fields - a list of fields
 * @returns {Object}
 */
export function fields(...fields: Fields): any;
/**
 * Merges fields into each item in an array.
 * @public
 * @example
 * merge(
 *   "$.books[*]",
 *   fields(
 *     field( "publisher", sourceValue("$.publisher") )
 *   )
 * )
 * @function
 * @public
 * @param {DataSource} dataSource
 * @param {Object} fields - Group of fields to merge in.
 * @returns {DataSource}
 */
export function merge(dataSource: DataSource, fields: any): DataSource;
/**
 * Groups an array of objects by a specified key path.
 * @public
 * @example
 * const users = [
 *   { name: 'Alice', age: 25, city: 'New York' },
 *   { name: 'Bob', age: 30, city: 'San Francisco' },
 *   { name: 'Charlie', age: 25, city: 'New York' },
 *   { name: 'David', age: 30, city: 'San Francisco' }
 * ];
 * group(users, 'city');
 * // state is { data: { 'New York': [/Alice, Charlie/], 'San Francisco': [ /Bob, David / ] }
 * @function
 * @public
 * @param {Object[]} arrayOfObjects - The array of objects to be grouped.
 * @param {string} keyPath - The key path to group by.
 * @param {function} callback - (Optional) Callback function
 * @returns {Operation}
 */
export function group(arrayOfObjects: any[], keyPath: string, callback?: Function): Operation;
/**
 * Returns the index of the current array being iterated.
 * To be used with `each` as a data source.
 * @public
 * @function
 * @example
 * index()
 * @returns {DataSource}
 */
export function index(): DataSource;
/**
 * Turns an array into a string, separated by X.
 * @public
 * @function
 * @example
 * field("destination_string__c", function(state) {
 *   return arrayToString(dataValue("path_of_array")(state), ', ')
 * })
 * @param {array} arr - Array of toString'able primatives.
 * @param {string} separator - Separator string.
 * @returns {string}
 */
export function arrayToString(arr: any[], separator: string): string;
/**
 * Ensures primitive data types are wrapped in an array.
 * Does not affect array objects.
 * @public
 * @function
 * @example
 * each(function(state) {
 *   return toArray( dataValue("path_of_array")(state) )
 * }, ...)
 * @param {any} arg - Data required to be in an array
 * @returns {array}
 */
export function toArray(arg: any): any[];
/**
 * Prepares next state
 * @public
 * @function
 * @example
 * composeNextState(state, response)
 * @param {State} state - state
 * @param {Object} response - Response to be added
 * @returns {State}
 */
export function composeNextState(state: State, response: any): State;
/**
 * Substitutes underscores for spaces and proper-cases a string
 * @public
 * @function
 * @example
 * field("destination_string__c", humanProper(state.data.path_to_string))
 * @param {string} str - String that needs converting
 * @returns {string}
 */
export function humanProper(str: string): string;
/**
 * Splits an object into two objects based on a list of keys.
 * The first object contains the keys that are not in the list,
 * and the second contains the keys that are.
 * @public
 * @function
 * @param {Object} obj - The object to split.
 * @param {string[]} keys - List of keys to split on.
 * @returns {Object[]} - Tuple of objects, first object contains keys not in list, second contains keys that are.
 */
export function splitKeys(obj: any, keys: string[]): any[];
/**
 * Replaces emojis in a string.
 * @public
 * @function
 * @example
 * scrubEmojis('DoveüïäÔ∏è‚≠ê 29')
 * @param {string} text - String that needs to be cleaned
 * @param {string} replacementChars - Characters that replace the emojis
 * @returns {string}
 */
export function scrubEmojis(text: string, replacementChars: string): string;
/**
 * Chunks an array into an array of arrays, each with no more than a certain size.
 * @public
 * @function
 * @example
 * chunk([1,2,3,4,5], 2)
 * @param {Object} array - Array to be chunked
 * @param {Integer} chunkSize - The maxiumum size of each chunks
 * @returns {Object}
 */
export function chunk(array: any, chunkSize: Integer): any;
/**
 * Takes a CSV file string or stream and parsing options as input, and returns a promise that
 * resolves to the parsed CSV data as an array of objects.
 * Options for `parsingOptions` include:
 * - `delimiter` {string/Buffer/[string/Buffer]} - Defines the character(s) used to delineate the fields inside a record. Default: `','`
 * - `quote` {string/Buffer/[string/Buffer]} - Defines the characters used to surround a field. Default: `'"'`
 * - `escape` {Buffer/string/null/boolean} - Set the escape character as one character/byte only. Default: `"`
 * - `columns` {boolean / array / function} - Generates record in the form of object literals. Default: `true`
 * - `bom` {boolean} - Strips the {@link https://en.wikipedia.org/wiki/Byte_order_mark byte order mark (BOM)} from the input string or buffer. Default: `true`
 * - `trim` {boolean} - Ignore whitespace characters immediately around the `delimiter`. Default: `true`
 * - `ltrim` {boolean} - Ignore whitespace characters from the left side of a CSV field. Default: `true`
 * - `rtrim` {boolean} - Ignore whitespace characters from the right side of a CSV field. Default: `true`
 * - `chunkSize` {number} - The size of each chunk of CSV data. Default: `Infinity`
 * - `skip_empty_lines` {boolean} - Ignore empty lines in the CSV file. Default: `true`
 * @public
 * @function
 * @param {String | Stream} csvData - A CSV string or a readable stream
 * @param {Object} [parsingOptions] - Optional. Parsing options for converting CSV to JSON.
 * @param {function} [callback] - (Optional) callback function. If used it will be called state and an array of rows.
 * @returns {Operation} The function returns a Promise that resolves to the result of parsing a CSV `stringOrStream`.
 */
export function parseCsv(csvData: string | Stream, parsingOptions?: any, callback?: Function): Operation;
/**
 * Validate against a JSON schema. Any erors are written to an array at `state.validationErrors`.
 * Schema can be passed directly, loaded as a JSON path from state, or loaded from a URL
 * Data can be passed directly or loaded as a JSON path from state.
 * By default, schema is loaded from `state.schema` and data from `state.data`.
 * @pubic
 * @function
 * @param {string|object} schema - The schema, path or URL to validate against
 * @param {string|object} data - The data or path to validate
 * @example <caption>Validate `state.data` with `state.schema`</caption>
 * validate()
 * @example <caption>Validate form data at `state.form` with a schema from a URL</caption>
 * validate("https://www.example.com/schema/record", "form")
 * @example <caption>Validate the each item in `state.records` with a schema from a URL</caption>
 * each("records[*]", validate("https://www.example.com/schema/record"))
 * @returns {Operation}
 */
export function validate(schema?: string | object, data?: string | object): Operation;
/**
 * Sets a cursor property on state.
 * Supports natural language dates like `now`, `today`, `yesterday`, `n hours ago`, `n days ago`, and `start`,
 * which will be converted relative to the environment (ie, the Lightning or CLI locale). Custom timezones
 * are not yet supported.
 * You can provide a formatter to customise the final cursor value, which is useful for normalising
 * different inputs. The custom formatter runs after natural language date conversion.
 * See the usage guide at {@link https://docs.openfn.org/documentation/jobs/job-writing-guide#using-cursors}
 * @public
 * @function
 * @example <caption>Use a cursor from state if present, or else use the default value</caption>
 * cursor($.cursor, { defaultValue: 'today' })
 * @example <caption>Use a pagination cursor</caption>
 * cursor(22)
 * @param {any} value - the cursor value. Usually an ISO date, natural language date, or page number
 * @param {object} options - options to control the cursor.
 * @param {string} options.key - set the cursor key. Will persist through the whole run.
 * @param {any} options.defaultValue - the value to use if value is falsy
 * @param {Function} options.format - custom formatter for the final cursor value
 * @returns {Operation}
 */
export function cursor(value: any, options?: {
    key: string;
    defaultValue: any;
    format: Function;
}): Operation;
/**
 * Asserts the given expression or function resolves to `true`, or else throws an exception. Optionally accepts and error message.
 * @public
 * @function
 * @example
 * assert('a' === 'b', '"a" is not equal to "b"')
 * @param {any} expression  - The expression or function to be evaluated.
 * @param {string} errorMessage - The error message thrown in case of a failed state.
 * @returns {operation}
 */
export function assert(expression: any, errorMessage: string): operation;
/**
 * Outputs a message, like calling `console.log`. Use this at the top level of your job code, but not inside callbacks.
 * @public
 * @function
 * @example <caption>Log values from state</caption>
 * log('Patient List::', $.patients);
 * @example <caption>Use console.log inside a callback or fn block</caption>
 * fn((state) => {
 *   console.log(state.data);
 *   return state;
 * })
 * @param {any} args - A value or message to display in the logs
 * @returns {Operation}
 */
export function log(...args: any): Operation;
/**
 * Outputs a message to the console with the debug log level. This is usually filtered out by default. Use this at the top level of your job code, but not inside callbacks.
 * @public
 * @function
 * @example <caption>Log values from state</caption>
 * debug('Patient List::', $.patients);
 * @example <caption>Use console.debug inside a callback or fn block</caption>
 * fn((state) => {
 *   console.debug(state.data);
 *   return state;
 * })

 * @param {any} args - A value or message to display in the logs
 * @returns {Operation}
 */
export function debug(...args: any): Operation;
/**
 * Run an operation and save the result to a custom key in state instead of overwriting state.data.
 * @public
 * @function
 * @example <caption>Fetch cce-data from collections and store them under state.cceData</caption>
 * as('cceData', collections.get('cce-data-dhis2', { key: `*:*:${$.syncedAt}*` }));
 * @param {string} key - The state key to assign the result of the operation to.
 * @param {function} operation -  An operation that returns a new state object with a `data` property
 * @returns {Operation}
 */
export function as(key: string, operation: Function): Operation;
export { _ };
export function map(path: string | any[], callback: Function): State;
