var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/util/index.js
var util_exports = {};
__export(util_exports, {
  ERROR_ABSOLUTE_URL: () => ERROR_ABSOLUTE_URL,
  ERROR_URL_MISMATCH: () => ERROR_URL_MISMATCH,
  assertRelativeUrl: () => assertRelativeUrl,
  decode: () => decode,
  del: () => del,
  enableMockClient: () => enableMockClient,
  encode: () => encode,
  expandReferences: () => expandReferences,
  get: () => get,
  logResponse: () => logResponse,
  makeBasicAuthHeader: () => makeBasicAuthHeader,
  normalizeOauthConfig: () => normalizeOauthConfig,
  parseDate: () => parse_date_default,
  parseUrl: () => parseUrl,
  post: () => post,
  put: () => put,
  request: () => request,
  throwError: () => throw_error_default,
  uuid: () => uuid
});
module.exports = __toCommonJS(util_exports);

// src/util/http.js
var import_undici = require("undici");
var import_http_status_codes = require("http-status-codes");
var import_node_stream = require("stream");
var import_node_querystring = __toESM(require("querystring"), 1);
var import_node_path = __toESM(require("path"), 1);

// src/util/throw-error.js
var throw_error_default = (code, { description, fix, ...extras } = {}) => {
  const message = description ? `${code}: ${description}` : code;
  const e = new Error(message);
  e.code = code;
  if (description) {
    e.description = description;
  }
  if (fix) {
    e.fix = fix;
  }
  for (const key in extras) {
    e[key] = extras[key];
  }
  throw e;
};

// src/util/base64.js
var import_lodash = __toESM(require("lodash"), 1);
var encode = (data, options = { parseJson: true }) => {
  let str = data;
  if (typeof data !== "string" && options.parseJson) {
    try {
      str = JSON.stringify(str);
    } catch (e) {
      console.log(e.message);
    }
  }
  return Buffer.from(str, "utf-8").toString("base64");
};
var decode = (base64Data, options = { parseJson: true }) => {
  let decodedValue = Buffer.from(base64Data, "base64").toString("utf-8");
  if ((import_lodash.default.startsWith(decodedValue, "[") || import_lodash.default.startsWith(decodedValue, "{")) && options.parseJson) {
    try {
      decodedValue = JSON.parse(decodedValue);
    } catch (e) {
      console.log(e.message);
    }
  }
  return decodedValue;
};

// src/util/http.js
var clients = /* @__PURE__ */ new Map();
var makeBasicAuthHeader = (username, password) => {
  const buff = Buffer.from(`${username}:${password}`);
  const credentials = buff.toString("base64");
  return { Authorization: `Basic ${credentials}` };
};
var logResponse = (response) => {
  const { method, url, statusCode, duration, query } = response;
  if (method && url && duration && statusCode) {
    const urlWithQuery = Object.keys(query || {}).length ? `${url}?${new URLSearchParams(query).toString()}` : url;
    const message = `${method} ${urlWithQuery} - ${statusCode} in ${duration}ms`;
    if (response instanceof Error) {
      console.error(message);
      console.error("response body: ");
      console.error(response.body || "[no body]");
    } else {
      console.log(message);
    }
  }
  return response;
};
var getClient = (baseUrl, options) => {
  const { tls } = options;
  if (!clients.has(baseUrl)) {
    clients.set(baseUrl, new import_undici.Client(baseUrl, { connect: tls }));
  }
  return clients.get(baseUrl);
};
var enableMockClient = (baseUrl, options = {}) => {
  const { defaultContentType = "application/json" } = options;
  const mockAgent = new import_undici.MockAgent({ connections: 1 });
  mockAgent.disableNetConnect();
  const client = mockAgent.get(baseUrl);
  if (!clients.has(baseUrl)) {
    if (defaultContentType) {
      const _intercept = client.intercept;
      client.intercept = (...args) => {
        const interceptor = _intercept.apply(client, args);
        const _reply = interceptor.reply;
        const ensureJsonHeader = (headers = {}) => {
          const hasJsonHeader = Object.keys(headers).find(
            (k) => /content-type/i.test(k)
          );
          if (!hasJsonHeader) {
            headers["content-type"] = defaultContentType;
          }
        };
        const reply = (...args2) => {
          if (typeof args2[0] === "function") {
            const response = _reply.apply(interceptor, args2);
            if (response.body) {
              response.headers ?? (response.headers = {});
              ensureJsonHeader(response.headers);
            }
            return response;
          } else {
            const [code, data, options2 = {}] = args2;
            if (data) {
              options2.headers ?? (options2.headers = {});
              ensureJsonHeader(options2.headers);
            }
            return _reply.call(interceptor, code, data, options2);
          }
        };
        interceptor.reply = reply;
        return interceptor;
      };
    }
    clients.set(baseUrl, client);
  }
  return client;
};
var assertOK = async (response, errorMap, fullUrl, method, startTime) => {
  if (errorMap === false) {
    return;
  }
  const errMapMessage = errorMap[response.statusCode];
  const isError = typeof errMapMessage === "boolean" ? errMapMessage : errMapMessage || response.statusCode >= 400;
  if (isError) {
    const body = await readResponseBody(response);
    const statusText = (0, import_http_status_codes.getReasonPhrase)(response.statusCode);
    const defaultErrorMessage = `${method} to ${fullUrl} returned ${response.statusCode}: ${statusText}`;
    const duration = Date.now() - startTime;
    const errMessage = typeof errMapMessage === "function" ? errMapMessage(response) : errMapMessage || defaultErrorMessage;
    const error = new Error(errMessage);
    error.statusCode = response.statusCode;
    error.statusMessage = statusText;
    error.url = fullUrl;
    error.duration = duration;
    error.method = method;
    error.body = body;
    error.headers = response.headers;
    throw error;
  }
};
var ERROR_ABSOLUTE_URL = "Absolute URLs not supported";
var assertRelativeUrl = (path2) => {
  if (/https?:\/\//.test(path2)) {
    const e = new Error("UNEXPECTED_ABSOLUTE_URL");
    e.code = "UNEXPECTED_ABSOLUTE_URL";
    e.description = "An absolute URL was provided (https://...) but only a path (/a/b/c) is supported";
    e.url = path2;
    e.fix = "Remove the protocol, domain and origin from the provided URL. Maybe you need to use the generic HTTP helper functions instead?";
    throw e;
  }
};
var ERROR_URL_MISMATCH = "Target origin does not match baseUrl origin";
var parseUrl = (pathOrUrl = "", baseUrl) => {
  let fullUrl;
  if (/https?:\/\//.test(pathOrUrl)) {
    fullUrl = new URL(pathOrUrl);
    if (baseUrl) {
      const base = new URL(baseUrl);
      if (fullUrl.origin !== base.origin) {
        const e = new Error(ERROR_URL_MISMATCH);
        e.code = "BASE_URL_MISMATCH";
        e.description = `A request was attempted to an absolute URL, but a different base URL was specified. This is a potential security violation.`;
        e.target = pathOrUrl;
        e.baseUrl = baseUrl;
        e.fix = "Try using a generic HTTP function to access the target URL";
        throw e;
      }
    }
  } else if (baseUrl) {
    fullUrl = new URL(import_node_path.default.join(baseUrl, pathOrUrl));
  } else {
    new URL(pathOrUrl);
  }
  return {
    url: fullUrl.toString(),
    baseUrl: fullUrl.origin,
    path: fullUrl.pathname,
    query: import_node_querystring.default.parse(fullUrl.searchParams.toString())
  };
};
async function request(method, fullUrlOrPath, options = {}) {
  const startTime = Date.now();
  const {
    url,
    baseUrl,
    path: path2,
    query: urlQuery
  } = parseUrl(fullUrlOrPath, options.baseUrl);
  const {
    headers = {},
    query: optionQuery = {},
    body,
    errors = {},
    timeout = 3e5,
    tls = {},
    parseAs = "auto",
    maxRedirections
  } = options;
  const client = getClient(baseUrl, { tls });
  const queryParams = {
    ...optionQuery,
    ...urlQuery
  };
  const response = await client.request({
    path: path2,
    query: queryParams,
    method,
    headers,
    body: encodeRequestBody(body),
    throwOnError: false,
    maxRedirections,
    bodyTimeout: timeout,
    headersTimeout: timeout,
    origin: baseUrl
  });
  const statusText = (0, import_http_status_codes.getReasonPhrase)(response.statusCode);
  await assertOK(response, errors, url, method, startTime);
  const responseBody = await readResponseBody(response, parseAs);
  const endTime = Date.now();
  const duration = endTime - startTime;
  const requestResponse = {
    url,
    method,
    statusCode: response.statusCode,
    statusMessage: statusText,
    headers: response.headers,
    body: responseBody,
    duration
  };
  if (Object.keys(queryParams).length > 0) {
    requestResponse.query = queryParams;
  }
  return requestResponse;
}
function encodeRequestBody(body) {
  if (!body) {
    return void 0;
  }
  if (Buffer.isBuffer(body) || body instanceof import_node_stream.Readable || typeof body === "string") {
    return body;
  }
  if (typeof body === "object") {
    if (Symbol.asyncIterator in Object(body) || Symbol.iterator in Object(body) || body instanceof FormData) {
      return body;
    }
    return JSON.stringify(body);
  }
  throw new Error("Unsupported body type");
}
async function readResponseBody(response, parseAs) {
  let contentLength = -1;
  if ("content-length" in response.headers) {
    contentLength = parseInt(response.headers["content-length"]);
  }
  const contentType = response.headers["content-type"];
  if (contentLength === 0 || !contentType || response.statusCode === 204) {
    return;
  }
  try {
    switch (parseAs) {
      case "json":
        return await response.body.json();
      case "text":
        return response.body.text();
      case "stream":
        return response.body;
      case "base64":
        const arrayBuffer = await response.body.arrayBuffer();
        return encode(arrayBuffer, { parseJson: false });
      default:
        return contentType && contentType.includes("application/json") ? await response.body.json() : response.body.text();
    }
  } catch (error) {
    throw_error_default(response.statusCode, {
      description: "Error parsing the response body",
      parseAs,
      contentType,
      bodyLength: contentLength,
      error: error.message
    });
  }
}
var get = (url, options) => request("GET", url, options);
var post = (url, body, options) => request("POST", url, { body, ...options });
var put = (url, body, options) => request("PUT", url, { body, ...options });
var del = (url, body, options) => request("DELETE", url, { body, ...options });

// src/util/references.js
var import_node_stream2 = require("stream");
function expandReferences(state, ...args) {
  return args.map((value) => expandReference(state, value));
}
var isStream = (value) => {
  if (value && typeof value == "object") {
    if (value instanceof import_node_stream2.Readable || value instanceof import_node_stream2.Writable) {
      return true;
    }
    if (value.pipeTo || value.pipe) {
      return true;
    }
  }
  return false;
};
function expandReference(state, value) {
  var _a;
  if (Buffer.isBuffer(value) || ((_a = value == null ? void 0 : value.constructor) == null ? void 0 : _a.name) === "RegExp") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map((v) => expandReference(state, v));
  }
  if (typeof value == "object" && !!value && !isStream(value)) {
    return Object.keys(value).reduce((acc, key) => {
      return { ...acc, [key]: expandReference(state, value[key]) };
    }, {});
  }
  if (typeof value == "function") {
    return expandReference(state, value(state));
  }
  return value;
}
function normalizeOauthConfig(configuration) {
  const { access_token, accessToken } = configuration;
  if (access_token && accessToken)
    throw new Error(
      'Both "accessToken" & "access_token" keys found in configuration; please use only "access_token" for OAuth2 credentials.'
    );
  if (access_token)
    return { ...configuration, accessToken: access_token };
  console.log(
    'Key "access_token" not found in state.configuration;',
    "is this a standard OAuth 2.0 JSON credential?"
  );
  if (accessToken)
    console.log('Using "accessToken" from state.configuration');
  return configuration;
}

// src/util/parse-date.js
var import_date_fns = require("date-fns");
var parse_date_default = (d, startDate) => {
  try {
    if (d === "start") {
      return startDate;
    } else if (d === "now" || d === "end") {
      return new Date();
    } else if (d === "today") {
      return (0, import_date_fns.startOfToday)();
    } else if (d === "yesterday") {
      return (0, import_date_fns.startOfYesterday)();
    } else if (/(hours? ago)$/.test(d)) {
      const [diff] = d.match(/\d+/);
      return (0, import_date_fns.subHours)(new Date(), diff);
    } else if (/(days? ago)$/.test(d)) {
      const [diff] = d.match(/\d+/);
      return (0, import_date_fns.startOfDay)((0, import_date_fns.subDays)(new Date(), diff));
    }
  } catch (e) {
    console.log(`Error converting ${d} into a date`);
    console.log(e);
  }
  return d;
};

// src/util/uuid.js
var import_node_crypto = require("crypto");
var uuid = () => (0, import_node_crypto.randomUUID)();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ERROR_ABSOLUTE_URL,
  ERROR_URL_MISMATCH,
  assertRelativeUrl,
  decode,
  del,
  enableMockClient,
  encode,
  expandReferences,
  get,
  logResponse,
  makeBasicAuthHeader,
  normalizeOauthConfig,
  parseDate,
  parseUrl,
  post,
  put,
  request,
  throwError,
  uuid
});
