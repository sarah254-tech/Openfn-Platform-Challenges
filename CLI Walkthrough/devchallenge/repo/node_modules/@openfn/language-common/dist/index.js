var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/Adaptor.js
var Adaptor_exports = {};
__export(Adaptor_exports, {
  _: () => _2,
  alterState: () => alterState,
  arrayToString: () => arrayToString,
  as: () => as,
  asData: () => asData,
  assert: () => assert,
  chunk: () => chunk,
  combine: () => combine,
  composeNextState: () => composeNextState,
  cursor: () => cursor,
  dataPath: () => dataPath,
  dataValue: () => dataValue,
  debug: () => debug,
  each: () => each,
  execute: () => execute,
  field: () => field,
  fields: () => fields,
  fn: () => fn,
  fnIf: () => fnIf,
  group: () => group,
  humanProper: () => humanProper,
  index: () => index,
  join: () => join,
  jsonValue: () => jsonValue,
  lastReferenceValue: () => lastReferenceValue,
  log: () => log,
  map: () => map,
  merge: () => merge,
  parseCsv: () => parseCsv,
  referencePath: () => referencePath,
  scrubEmojis: () => scrubEmojis,
  source: () => source,
  sourceValue: () => sourceValue,
  splitKeys: () => splitKeys,
  toArray: () => toArray,
  validate: () => validate
});
import { JSONPath } from "jsonpath-plus";
import { parse } from "csv-parse";
import { Readable as Readable3 } from "stream";
import { request as request2 } from "undici";
import dateFns from "date-fns";
import _2 from "lodash";

// src/util/index.js
var util_exports = {};
__export(util_exports, {
  ERROR_ABSOLUTE_URL: () => ERROR_ABSOLUTE_URL,
  ERROR_URL_MISMATCH: () => ERROR_URL_MISMATCH,
  assertRelativeUrl: () => assertRelativeUrl,
  decode: () => decode,
  del: () => del,
  enableMockClient: () => enableMockClient,
  encode: () => encode,
  expandReferences: () => expandReferences,
  get: () => get,
  logResponse: () => logResponse,
  makeBasicAuthHeader: () => makeBasicAuthHeader,
  normalizeOauthConfig: () => normalizeOauthConfig,
  parseDate: () => parse_date_default,
  parseUrl: () => parseUrl,
  post: () => post,
  put: () => put,
  request: () => request,
  throwError: () => throw_error_default,
  uuid: () => uuid
});

// src/util/http.js
import { Client, MockAgent } from "undici";
import { getReasonPhrase } from "http-status-codes";
import { Readable } from "stream";
import querystring from "querystring";
import path from "path";

// src/util/throw-error.js
var throw_error_default = (code, { description, fix, ...extras } = {}) => {
  const message = description ? `${code}: ${description}` : code;
  const e = new Error(message);
  e.code = code;
  if (description) {
    e.description = description;
  }
  if (fix) {
    e.fix = fix;
  }
  for (const key in extras) {
    e[key] = extras[key];
  }
  throw e;
};

// src/util/base64.js
import _ from "lodash";
var encode = (data, options2 = { parseJson: true }) => {
  let str = data;
  if (typeof data !== "string" && options2.parseJson) {
    try {
      str = JSON.stringify(str);
    } catch (e) {
      console.log(e.message);
    }
  }
  return Buffer.from(str, "utf-8").toString("base64");
};
var decode = (base64Data, options2 = { parseJson: true }) => {
  let decodedValue = Buffer.from(base64Data, "base64").toString("utf-8");
  if ((_.startsWith(decodedValue, "[") || _.startsWith(decodedValue, "{")) && options2.parseJson) {
    try {
      decodedValue = JSON.parse(decodedValue);
    } catch (e) {
      console.log(e.message);
    }
  }
  return decodedValue;
};

// src/util/http.js
var clients = /* @__PURE__ */ new Map();
var makeBasicAuthHeader = (username, password) => {
  const buff = Buffer.from(`${username}:${password}`);
  const credentials = buff.toString("base64");
  return { Authorization: `Basic ${credentials}` };
};
var logResponse = (response) => {
  const { method, url, statusCode, duration, query } = response;
  if (method && url && duration && statusCode) {
    const urlWithQuery = Object.keys(query || {}).length ? `${url}?${new URLSearchParams(query).toString()}` : url;
    const message = `${method} ${urlWithQuery} - ${statusCode} in ${duration}ms`;
    if (response instanceof Error) {
      console.error(message);
      console.error("response body: ");
      console.error(response.body || "[no body]");
    } else {
      console.log(message);
    }
  }
  return response;
};
var getClient = (baseUrl, options2) => {
  const { tls } = options2;
  if (!clients.has(baseUrl)) {
    clients.set(baseUrl, new Client(baseUrl, { connect: tls }));
  }
  return clients.get(baseUrl);
};
var enableMockClient = (baseUrl, options2 = {}) => {
  const { defaultContentType = "application/json" } = options2;
  const mockAgent = new MockAgent({ connections: 1 });
  mockAgent.disableNetConnect();
  const client = mockAgent.get(baseUrl);
  if (!clients.has(baseUrl)) {
    if (defaultContentType) {
      const _intercept = client.intercept;
      client.intercept = (...args) => {
        const interceptor = _intercept.apply(client, args);
        const _reply = interceptor.reply;
        const ensureJsonHeader = (headers = {}) => {
          const hasJsonHeader = Object.keys(headers).find(
            (k) => /content-type/i.test(k)
          );
          if (!hasJsonHeader) {
            headers["content-type"] = defaultContentType;
          }
        };
        const reply = (...args2) => {
          if (typeof args2[0] === "function") {
            const response = _reply.apply(interceptor, args2);
            if (response.body) {
              response.headers ?? (response.headers = {});
              ensureJsonHeader(response.headers);
            }
            return response;
          } else {
            const [code, data, options3 = {}] = args2;
            if (data) {
              options3.headers ?? (options3.headers = {});
              ensureJsonHeader(options3.headers);
            }
            return _reply.call(interceptor, code, data, options3);
          }
        };
        interceptor.reply = reply;
        return interceptor;
      };
    }
    clients.set(baseUrl, client);
  }
  return client;
};
var assertOK = async (response, errorMap, fullUrl, method, startTime) => {
  if (errorMap === false) {
    return;
  }
  const errMapMessage = errorMap[response.statusCode];
  const isError = typeof errMapMessage === "boolean" ? errMapMessage : errMapMessage || response.statusCode >= 400;
  if (isError) {
    const body = await readResponseBody(response);
    const statusText = getReasonPhrase(response.statusCode);
    const defaultErrorMessage = `${method} to ${fullUrl} returned ${response.statusCode}: ${statusText}`;
    const duration = Date.now() - startTime;
    const errMessage = typeof errMapMessage === "function" ? errMapMessage(response) : errMapMessage || defaultErrorMessage;
    const error = new Error(errMessage);
    error.statusCode = response.statusCode;
    error.statusMessage = statusText;
    error.url = fullUrl;
    error.duration = duration;
    error.method = method;
    error.body = body;
    error.headers = response.headers;
    throw error;
  }
};
var ERROR_ABSOLUTE_URL = "Absolute URLs not supported";
var assertRelativeUrl = (path2) => {
  if (/https?:\/\//.test(path2)) {
    const e = new Error("UNEXPECTED_ABSOLUTE_URL");
    e.code = "UNEXPECTED_ABSOLUTE_URL";
    e.description = "An absolute URL was provided (https://...) but only a path (/a/b/c) is supported";
    e.url = path2;
    e.fix = "Remove the protocol, domain and origin from the provided URL. Maybe you need to use the generic HTTP helper functions instead?";
    throw e;
  }
};
var ERROR_URL_MISMATCH = "Target origin does not match baseUrl origin";
var parseUrl = (pathOrUrl = "", baseUrl) => {
  let fullUrl;
  if (/https?:\/\//.test(pathOrUrl)) {
    fullUrl = new URL(pathOrUrl);
    if (baseUrl) {
      const base = new URL(baseUrl);
      if (fullUrl.origin !== base.origin) {
        const e = new Error(ERROR_URL_MISMATCH);
        e.code = "BASE_URL_MISMATCH";
        e.description = `A request was attempted to an absolute URL, but a different base URL was specified. This is a potential security violation.`;
        e.target = pathOrUrl;
        e.baseUrl = baseUrl;
        e.fix = "Try using a generic HTTP function to access the target URL";
        throw e;
      }
    }
  } else if (baseUrl) {
    fullUrl = new URL(path.join(baseUrl, pathOrUrl));
  } else {
    new URL(pathOrUrl);
  }
  return {
    url: fullUrl.toString(),
    baseUrl: fullUrl.origin,
    path: fullUrl.pathname,
    query: querystring.parse(fullUrl.searchParams.toString())
  };
};
async function request(method, fullUrlOrPath, options2 = {}) {
  const startTime = Date.now();
  const {
    url,
    baseUrl,
    path: path2,
    query: urlQuery
  } = parseUrl(fullUrlOrPath, options2.baseUrl);
  const {
    headers = {},
    query: optionQuery = {},
    body,
    errors = {},
    timeout = 3e5,
    tls = {},
    parseAs = "auto",
    maxRedirections
  } = options2;
  const client = getClient(baseUrl, { tls });
  const queryParams = {
    ...optionQuery,
    ...urlQuery
  };
  const response = await client.request({
    path: path2,
    query: queryParams,
    method,
    headers,
    body: encodeRequestBody(body),
    throwOnError: false,
    maxRedirections,
    bodyTimeout: timeout,
    headersTimeout: timeout,
    origin: baseUrl
  });
  const statusText = getReasonPhrase(response.statusCode);
  await assertOK(response, errors, url, method, startTime);
  const responseBody = await readResponseBody(response, parseAs);
  const endTime = Date.now();
  const duration = endTime - startTime;
  const requestResponse = {
    url,
    method,
    statusCode: response.statusCode,
    statusMessage: statusText,
    headers: response.headers,
    body: responseBody,
    duration
  };
  if (Object.keys(queryParams).length > 0) {
    requestResponse.query = queryParams;
  }
  return requestResponse;
}
function encodeRequestBody(body) {
  if (!body) {
    return void 0;
  }
  if (Buffer.isBuffer(body) || body instanceof Readable || typeof body === "string") {
    return body;
  }
  if (typeof body === "object") {
    if (Symbol.asyncIterator in Object(body) || Symbol.iterator in Object(body) || body instanceof FormData) {
      return body;
    }
    return JSON.stringify(body);
  }
  throw new Error("Unsupported body type");
}
async function readResponseBody(response, parseAs) {
  let contentLength = -1;
  if ("content-length" in response.headers) {
    contentLength = parseInt(response.headers["content-length"]);
  }
  const contentType = response.headers["content-type"];
  if (contentLength === 0 || !contentType || response.statusCode === 204) {
    return;
  }
  try {
    switch (parseAs) {
      case "json":
        return await response.body.json();
      case "text":
        return response.body.text();
      case "stream":
        return response.body;
      case "base64":
        const arrayBuffer = await response.body.arrayBuffer();
        return encode(arrayBuffer, { parseJson: false });
      default:
        return contentType && contentType.includes("application/json") ? await response.body.json() : response.body.text();
    }
  } catch (error) {
    throw_error_default(response.statusCode, {
      description: "Error parsing the response body",
      parseAs,
      contentType,
      bodyLength: contentLength,
      error: error.message
    });
  }
}
var get = (url, options2) => request("GET", url, options2);
var post = (url, body, options2) => request("POST", url, { body, ...options2 });
var put = (url, body, options2) => request("PUT", url, { body, ...options2 });
var del = (url, body, options2) => request("DELETE", url, { body, ...options2 });

// src/util/references.js
import { Readable as Readable2, Writable } from "stream";
function expandReferences(state, ...args) {
  return args.map((value) => expandReference(state, value));
}
var isStream = (value) => {
  if (value && typeof value == "object") {
    if (value instanceof Readable2 || value instanceof Writable) {
      return true;
    }
    if (value.pipeTo || value.pipe) {
      return true;
    }
  }
  return false;
};
function expandReference(state, value) {
  var _a;
  if (Buffer.isBuffer(value) || ((_a = value == null ? void 0 : value.constructor) == null ? void 0 : _a.name) === "RegExp") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map((v) => expandReference(state, v));
  }
  if (typeof value == "object" && !!value && !isStream(value)) {
    return Object.keys(value).reduce((acc, key) => {
      return { ...acc, [key]: expandReference(state, value[key]) };
    }, {});
  }
  if (typeof value == "function") {
    return expandReference(state, value(state));
  }
  return value;
}
function normalizeOauthConfig(configuration) {
  const { access_token, accessToken } = configuration;
  if (access_token && accessToken)
    throw new Error(
      'Both "accessToken" & "access_token" keys found in configuration; please use only "access_token" for OAuth2 credentials.'
    );
  if (access_token)
    return { ...configuration, accessToken: access_token };
  console.log(
    'Key "access_token" not found in state.configuration;',
    "is this a standard OAuth 2.0 JSON credential?"
  );
  if (accessToken)
    console.log('Using "accessToken" from state.configuration');
  return configuration;
}

// src/util/parse-date.js
import { startOfToday, startOfYesterday, subHours, subDays, startOfDay } from "date-fns";
var parse_date_default = (d, startDate) => {
  try {
    if (d === "start") {
      return startDate;
    } else if (d === "now" || d === "end") {
      return new Date();
    } else if (d === "today") {
      return startOfToday();
    } else if (d === "yesterday") {
      return startOfYesterday();
    } else if (/(hours? ago)$/.test(d)) {
      const [diff] = d.match(/\d+/);
      return subHours(new Date(), diff);
    } else if (/(days? ago)$/.test(d)) {
      const [diff] = d.match(/\d+/);
      return startOfDay(subDays(new Date(), diff));
    }
  } catch (e) {
    console.log(`Error converting ${d} into a date`);
    console.log(e);
  }
  return d;
};

// src/util/uuid.js
import { randomUUID } from "crypto";
var uuid = () => randomUUID();

// src/Adaptor.js
var schemaCache = {};
function execute(...operations) {
  return (state) => {
    const start = Promise.resolve(state);
    return operations.reduce((acc, operation) => {
      return acc.then(operation);
    }, start);
  };
}
function alterState(func) {
  return fn(func);
}
function fn(func) {
  return (state) => {
    return func(state);
  };
}
function fnIf(condition, operation) {
  return (state) => {
    const [resolvedCondition] = expandReferences(state, condition);
    return resolvedCondition ? operation(state) : state;
  };
}
function jsonValue(obj, path2) {
  return JSONPath({ path: path2, json: obj })[0];
}
function sourceValue(path2) {
  return (state) => {
    return JSONPath({ path: path2, json: state })[0];
  };
}
function source(path2) {
  return (state) => {
    return JSONPath({ path: path2, json: state });
  };
}
function dataPath(path2) {
  const cleanPath = path2.match(/^[\$\.]*(.+)/)[1];
  return "$.data.".concat(cleanPath);
}
function dataValue(path2) {
  return sourceValue(dataPath(path2));
}
function referencePath(path2) {
  const cleanPath = path2.match(/^[\$\.]*(.+)/)[1];
  return "$.references".concat(cleanPath);
}
function lastReferenceValue(path2) {
  const lastReferencePath = referencePath("[0]".concat(".", path2));
  return sourceValue(lastReferencePath);
}
var map = function(path2, callback) {
  return async (state) => {
    const results = [];
    const values = typeof path2 === "string" ? source(path2)(state) : path2;
    let index2 = 0;
    for (const item of values) {
      const value = await callback(item, index2++, state);
      results.push(value);
    }
    return { ...state, data: results };
  };
};
function asData(data, state) {
  switch (typeof data) {
    case "string":
      return source(data)(state);
    case "object":
      return data;
    case "function":
      return data(state);
  }
}
function each(dataSource, operation) {
  if (!dataSource) {
    throw new TypeError("dataSource argument for each operation is invalid.");
  }
  return (state) => {
    return asData(dataSource, state).reduce((state2, data, index2) => {
      if (state2.then) {
        return state2.then((state3) => {
          return operation({ ...state3, data, index: index2 });
        });
      } else {
        return operation({ ...state2, data, index: index2 });
      }
    }, state);
  };
}
function combine(...operations) {
  return (state) => {
    return operations.reduce((state2, operation) => {
      if (state2.then) {
        return state2.then((state3) => {
          return { ...state3, ...operation(state3) };
        });
      } else {
        return { ...state2, ...operation(state2) };
      }
    }, state);
  };
}
function join(targetPath, sourcePath, targetKey) {
  return (state) => {
    return source(targetPath)(state).map((i) => {
      return { [targetKey]: sourceValue(sourcePath)(state), ...i };
    });
  };
}
function field(key, value) {
  return [key, value];
}
function fields(...fields2) {
  return _2.fromPairs(fields2);
}
function merge(dataSource, fields2) {
  return (state) => {
    const initialData = source(dataSource)(state);
    const [additionalData] = expandReferences(state, fields2);
    return initialData.reduce((acc, dataItem) => {
      return [...acc, { ...dataItem, ...additionalData }];
    }, []);
  };
}
function group(arrayOfObjects, keyPath, callback = (s) => s) {
  return (state) => {
    const [resolvedArray, resolvedKeyPath] = expandReferences(
      state,
      arrayOfObjects,
      keyPath
    );
    const results = _2.groupBy(
      resolvedArray,
      (item) => _2.get(item, resolvedKeyPath)
    );
    return callback({ ...state, data: _2.omit(results, [void 0]) });
  };
}
function index() {
  return (state) => {
    return state.index;
  };
}
function arrayToString(arr, separator) {
  return Array.apply(null, arr).join(separator);
}
function toArray(arg) {
  return new Array().concat(arg);
}
function composeNextState(state, response) {
  if (!state.references) {
    state.references = [];
  }
  return {
    ...state,
    data: response,
    references: [...state.references, state.data]
  };
}
function humanProper(str) {
  if (typeof str == "string") {
    return str.replace(/[_-]/g, " ").replace(/\w\S*/g, function(txt) {
      return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    });
  } else {
    return str;
  }
}
function splitKeys(obj, keys) {
  return Object.keys(obj).reduce(
    ([keep, split], key) => {
      const value = obj[key];
      if (keys.includes(key)) {
        return [keep, { ...split, [key]: value }];
      }
      return [{ ...keep, [key]: value }, split];
    },
    [{}, {}]
  );
}
function scrubEmojis(text, replacementChars) {
  if (!text)
    return text;
  if (replacementChars == "") {
    console.warn(
      "Removing characters from a string may create injection vulnerabilities;",
      "It's better to replace than remove.",
      "See https://www.unicode.org/reports/tr36/#Deletion_of_Noncharacters"
    );
  }
  const newChars = replacementChars || replacementChars == "" ? replacementChars : "\uFFFD";
  const emojisPattern = /(\uFE0F|\u00a9|\u00ae|[\u2000-\u3300]|\ud83c[\ud000-\udfff]|\ud83d[\ud000-\udfff]|\ud83e[\ud000-\udfff])/g;
  return text.replace(emojisPattern, newChars);
}
function chunk(array, chunkSize) {
  const output = [];
  for (var i = 0, len = array.length; i < len; i += chunkSize)
    output.push(array.slice(i, i + chunkSize));
  return output;
}
var getParser = (csvData, options2) => {
  if (typeof csvData === "string") {
    return parse(csvData, options2);
  }
  let stream = csvData;
  if (csvData instanceof ReadableStream) {
    stream = Readable3.from(csvData);
  }
  return stream.pipe(parse(options2));
};
function parseCsv(csvData, parsingOptions = {}, callback) {
  const defaultOptions = {
    delimiter: ",",
    quote: '"',
    escape: '"',
    columns: true,
    bom: true,
    trim: true,
    ltrim: true,
    rtrim: true,
    chunkSize: Infinity,
    skip_empty_lines: true
  };
  return async (state) => {
    const [resolvedCsvData, resolvedParsingOptions] = expandReferences(
      state,
      csvData,
      parsingOptions
    );
    const filteredOptions = Object.fromEntries(
      Object.entries(resolvedParsingOptions).filter(
        ([key]) => key in defaultOptions
      )
    );
    const options2 = { ...defaultOptions, ...filteredOptions };
    if (options2.chunkSize < 1) {
      throw new Error("chunkSize must be at least 1");
    }
    let buffer = [];
    const parser = getParser(resolvedCsvData, options2);
    const flushBuffer = async (currentState) => {
      const nextState = callback ? await callback(currentState, buffer) : composeNextState(currentState, buffer);
      buffer = [];
      return [nextState, buffer];
    };
    let result = state;
    for await (const record of parser) {
      buffer.push(record);
      if (buffer.length === options2.chunkSize) {
        const [nextState, nextBuffer] = await flushBuffer(result);
        result = nextState;
        buffer = nextBuffer;
      }
    }
    if (buffer.length) {
      [result] = await flushBuffer(result);
    }
    return result;
  };
}
var ajvVersions = {};
var getAjvVersion = async (schema) => {
  if (/^https?:\/\/json-schema.org\/draft\/2019/.test(schema)) {
    if (!ajvVersions["2019"]) {
      const Ajv = (await import("ajv/dist/2019.js")).default;
      ajvVersions["2019"] = new Ajv();
    }
    return ajvVersions["2019"];
  }
  if (/^https?:\/\/json-schema.org\/draft\/2020/.test(schema)) {
    if (!ajvVersions["2020"]) {
      const Ajv = (await import("ajv/dist/2020.js")).default;
      ajvVersions["2020"] = new Ajv();
    }
    return ajvVersions["2020"];
  }
  if (!ajvVersions["default"]) {
    const Ajv = (await import("ajv")).default;
    ajvVersions["default"] = new Ajv();
  }
  return ajvVersions["default"];
};
function validate(schema = "schema", data = "data") {
  return async (state) => {
    if (!state.validationErrors) {
      state.validationErrors = [];
    }
    const resolvedData = resolveData();
    const resolvedSchema = await resolveSchema();
    const schemaId = resolvedSchema.$id || "schema";
    if (!schemaCache[schemaId]) {
      const ajv = await getAjvVersion(resolvedSchema.$schema);
      schemaCache[schemaId] = ajv.compile(resolvedSchema);
    }
    const validate2 = schemaCache[schemaId];
    if (!validate2(resolvedData)) {
      state.validationErrors.push({
        data: state.data,
        errors: validate2.errors
      });
    }
    return state;
    async function resolveSchema() {
      const [schemaOrUrl] = expandReferences(state, schema);
      if (typeof schemaOrUrl === "string") {
        try {
          const url = new URL(schemaOrUrl);
          const response = await request2(url);
          return response.body.json();
        } catch (e) {
          if (e instanceof TypeError) {
            return JSONPath({ path: schemaOrUrl, json: state })[0];
          } else {
            console.error("Error fetching schema from ", schemaOrUrl);
            console.error(e);
          }
        }
      }
      return schemaOrUrl;
    }
    function resolveData() {
      const [d] = expandReferences(state, data);
      if (typeof d === "string") {
        return JSONPath({ path: d, json: state })[0];
      }
      return d;
    }
  };
}
var cursorStart = void 0;
var cursorKey = "cursor";
function cursor(value, options2 = {}) {
  return (state) => {
    const { format: format2, ...optionsWithoutFormat } = options2;
    const [resolvedValue, resolvedOptions] = expandReferences(
      state,
      value,
      optionsWithoutFormat
    );
    const {
      defaultValue,
      key
    } = resolvedOptions;
    if (key) {
      cursorKey = key;
    }
    if (!cursorStart) {
      cursorStart = new Date();
    }
    const cursor2 = resolvedValue ?? defaultValue;
    if (typeof cursor2 === "string") {
      const date = parse_date_default(cursor2, cursorStart);
      if (date instanceof Date && date.toString !== "Invalid Date") {
        state[cursorKey] = (format2 == null ? void 0 : format2(date)) ?? date.toISOString();
        const formatted = format2 ? state[cursorKey] : dateFns.format(date, "HH:MM d MMM yyyy (OOO)");
        console.log(`Setting ${cursorKey} "${cursor2}" to: ${formatted}`);
        return state;
      }
    }
    state[cursorKey] = (format2 == null ? void 0 : format2(cursor2)) ?? cursor2;
    console.log(`Setting ${cursorKey} to:`, state[cursorKey]);
    return state;
  };
}
function assert(expression, errorMessage) {
  return (state) => {
    const [resolvedValue, resolvedErrorMessage] = expandReferences(
      state,
      expression,
      errorMessage
    );
    if (!resolvedValue) {
      throw new Error(
        resolvedErrorMessage || `assertion statement failed with ${resolvedValue}`
      );
    }
    return state;
  };
}
function log(...args) {
  return (state) => {
    const [resolvedArgs] = expandReferences(state, args);
    console.log(...resolvedArgs);
    return state;
  };
}
function debug(...args) {
  return (state) => {
    const [resolvedArgs] = expandReferences(state, args);
    console.debug(...resolvedArgs);
    return state;
  };
}
function as(key, operation) {
  return async (state) => {
    const [resolvedKey] = expandReferences(state, key);
    const prevState = state.data;
    const result = await operation(state);
    const { data, ...rest } = result;
    state[resolvedKey] = data;
    state.data = prevState;
    return { ...state, ...rest };
  };
}

// src/beta.js
var beta_exports = {};
__export(beta_exports, {
  each: () => each2
});
function each2(dataSource, operation) {
  if (!dataSource) {
    throw new TypeError("dataSource argument for each operation is invalid.");
  }
  return (prevState) => {
    const items = asData(dataSource, prevState);
    const nextState = items.reduce(
      (state, data, index2) => {
        if (state.then) {
          return state.then((state2) => {
            return operation({ ...state2, data, index: index2 });
          });
        } else {
          return operation({ ...state, data, index: index2 });
        }
      },
      prevState
    );
    if (nextState.then) {
      return nextState.then((nextState2) => ({ ...nextState2, data: prevState.data }));
    } else {
      return { ...nextState, data: prevState.data };
    }
  };
}

// src/http.js
var http_exports = {};
__export(http_exports, {
  get: () => get2,
  options: () => options,
  post: () => post2,
  request: () => req
});
import set from "lodash/set";
var helpers = {
  json: function() {
    set(this, "headers.Content-Type", "application/json");
    return this;
  },
  basic: function(username, password) {
    const buff = Buffer.from(`${username}:${password}`);
    const credentials = buff.toString("base64");
    set(this, "headers.Authorization", `Basic ${credentials}`);
    return this;
  },
  bearer: function(token) {
    set(this, "headers.Authorization", `Bearer ${token}`);
    return this;
  },
  oauth: function(token) {
    set(this, "headers.Authorization", `Bearer ${token}`);
    return this;
  }
};
function options(opts = {}) {
  for (let h in helpers) {
    Object.defineProperty(opts, h, {
      enumerable: false,
      value: helpers[h]
    });
  }
  return opts;
}
var req = function(method, url, options2) {
  return async (state) => {
    const [resolvedMethod, resolvedUrl, resolvedOptions] = expandReferences(
      state,
      method,
      url,
      options2
    );
    const { body, ...responseWithoutBody } = await request(
      resolvedMethod,
      resolvedUrl,
      resolvedOptions
    );
    return {
      ...state,
      response: responseWithoutBody,
      data: body
    };
  };
};
function get2(url, options2) {
  return req("GET", url, options2);
}
function post2(url, data, options2) {
  return req("POST", url, { body: data, ...options2 });
}

// src/dateFns.js
var dateFns_exports = {};
__export(dateFns_exports, {
  format: () => format,
  parse: () => parse2
});
import {
  parse as parse2,
  format
} from "date-fns";

// src/index.js
var src_default = Adaptor_exports;
export {
  _2 as _,
  alterState,
  arrayToString,
  as,
  asData,
  assert,
  beta_exports as beta,
  chunk,
  combine,
  composeNextState,
  cursor,
  dataPath,
  dataValue,
  dateFns_exports as dateFns,
  debug,
  src_default as default,
  each,
  execute,
  field,
  fields,
  fn,
  fnIf,
  group,
  http_exports as http,
  humanProper,
  index,
  join,
  jsonValue,
  lastReferenceValue,
  log,
  map,
  merge,
  parseCsv,
  referencePath,
  scrubEmojis,
  source,
  sourceValue,
  splitKeys,
  toArray,
  util_exports as util,
  validate
};
