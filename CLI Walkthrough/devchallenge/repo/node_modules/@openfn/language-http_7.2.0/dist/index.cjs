var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.js
var src_exports = {};
__export(src_exports, {
  alterState: () => import_language_common3.alterState,
  arrayToString: () => import_language_common3.arrayToString,
  as: () => import_language_common3.as,
  chunk: () => import_language_common3.chunk,
  combine: () => import_language_common3.combine,
  cursor: () => import_language_common3.cursor,
  dataPath: () => import_language_common3.dataPath,
  dataValue: () => import_language_common3.dataValue,
  dateFns: () => import_language_common3.dateFns,
  default: () => src_default,
  del: () => del,
  each: () => import_language_common3.each,
  execute: () => execute,
  field: () => import_language_common3.field,
  fields: () => import_language_common3.fields,
  fn: () => import_language_common3.fn,
  fnIf: () => import_language_common3.fnIf,
  get: () => get,
  group: () => import_language_common3.group,
  humanProper: () => import_language_common3.humanProper,
  lastReferenceValue: () => import_language_common3.lastReferenceValue,
  map: () => import_language_common3.map,
  merge: () => import_language_common3.merge,
  parseCsv: () => import_language_common3.parseCsv,
  parseXML: () => parseXML,
  patch: () => patch,
  post: () => post,
  put: () => put,
  request: () => request2,
  scrubEmojis: () => import_language_common3.scrubEmojis,
  sourceValue: () => import_language_common3.sourceValue,
  splitKeys: () => import_language_common3.splitKeys,
  toArray: () => import_language_common3.toArray,
  util: () => util_exports
});
module.exports = __toCommonJS(src_exports);

// src/Adaptor.js
var Adaptor_exports = {};
__export(Adaptor_exports, {
  alterState: () => import_language_common3.alterState,
  arrayToString: () => import_language_common3.arrayToString,
  as: () => import_language_common3.as,
  chunk: () => import_language_common3.chunk,
  combine: () => import_language_common3.combine,
  cursor: () => import_language_common3.cursor,
  dataPath: () => import_language_common3.dataPath,
  dataValue: () => import_language_common3.dataValue,
  dateFns: () => import_language_common3.dateFns,
  del: () => del,
  each: () => import_language_common3.each,
  execute: () => execute,
  field: () => import_language_common3.field,
  fields: () => import_language_common3.fields,
  fn: () => import_language_common3.fn,
  fnIf: () => import_language_common3.fnIf,
  get: () => get,
  group: () => import_language_common3.group,
  humanProper: () => import_language_common3.humanProper,
  lastReferenceValue: () => import_language_common3.lastReferenceValue,
  map: () => import_language_common3.map,
  merge: () => import_language_common3.merge,
  parseCsv: () => import_language_common3.parseCsv,
  parseXML: () => parseXML,
  patch: () => patch,
  post: () => post,
  put: () => put,
  request: () => request2,
  scrubEmojis: () => import_language_common3.scrubEmojis,
  sourceValue: () => import_language_common3.sourceValue,
  splitKeys: () => import_language_common3.splitKeys,
  toArray: () => import_language_common3.toArray
});
var import_language_common2 = require("@openfn/language-common");

// src/util.js
var util_exports = {};
__export(util_exports, {
  CONTENT_TYPES: () => CONTENT_TYPES,
  decode: () => import_util.decode,
  encode: () => import_util.encode,
  getTLSOptions: () => getTLSOptions,
  request: () => request,
  uuid: () => import_util.uuid,
  xmlParser: () => xmlParser
});
var import_language_common = require("@openfn/language-common");
var import_util = require("@openfn/language-common/util");
var cheerio = __toESM(require("cheerio"), 1);
var import_cheerio_tableparser = __toESM(require("cheerio-tableparser"), 1);
function addAuth(configuration, headers) {
  if (headers.Authorization) {
    return;
  }
  const { username, password, access_token } = configuration ?? {};
  if (access_token) {
    Object.assign(headers, { Authorization: `Bearer ${access_token}` });
  } else if (username && password) {
    Object.assign(headers, (0, import_util.makeBasicAuthHeader)(username, password));
  }
}
function encodeFormBody(data) {
  const form = new FormData();
  for (const [key, value] of Object.entries(data)) {
    form.append(key, value);
  }
  return form;
}
function getTLSOptions(state, requestOptions) {
  const { tls: tlsConfig } = state.configuration || {};
  const tls = requestOptions.tls ?? requestOptions.agentOptions ?? tlsConfig;
  return tls;
}
var assertUrl = (pathOrUrl, baseUrl) => {
  if (!baseUrl && pathOrUrl && !/^https?:\/\//.test(pathOrUrl)) {
    const e = new Error("UNEXPECTED_RELATIVE_URL");
    e.code = "UNEXPECTED_RELATIVE_URL";
    e.description = `You passed a relative URL but didn't set baseUrl`;
    e.url = pathOrUrl;
    e.fix = `Set the baseUrl on state.configuration or use an absolute URL, like https://example.com/api/${pathOrUrl}`;
    throw e;
  }
  if (!baseUrl && !pathOrUrl) {
    const e = new Error("NO_URL");
    e.code = "NO_URL";
    e.description = `No URL provided`;
    e.fix = `Make sure to pass a URL string into the request. You may need to set a baseURL on state.configuration.`;
    throw e;
  }
};
var CONTENT_TYPES = {
  xml: "application/xml",
  json: "application/json",
  string: "text/plain"
};
function request(method, path, params) {
  return (state) => {
    var _a;
    const [resolvedPath, resolvedParams = {}] = (0, import_util.expandReferences)(
      state,
      path,
      params
    );
    let { body, contentType = "json", headers = {}, parseAs } = resolvedParams;
    const contentTypeHeader = Object.keys(headers).find(
      (key) => key.toLowerCase() === "content-type"
    );
    if (contentType === "form") {
      delete headers[contentTypeHeader];
      headers = { ...headers };
      body = encodeFormBody(body);
    } else if (contentTypeHeader) {
      headers = { ...headers };
    } else {
      headers = {
        ...headers,
        "Content-Type": CONTENT_TYPES[contentType] || "application/json"
      };
    }
    const baseUrl = (_a = state.configuration) == null ? void 0 : _a.baseUrl;
    assertUrl(resolvedPath, baseUrl);
    if (baseUrl) {
      addAuth(state.configuration, headers);
    }
    const maxRedirections = resolvedParams.maxRedirections ?? (resolvedParams.followAllRedirects === false ? 0 : 5);
    const tls = getTLSOptions(state, resolvedParams);
    if (resolvedParams.agentOptions) {
      console.warn(
        "WARNING: The `agentOptions` option has been deprecated. Add `tls` to state.configuration instead."
      );
    }
    const options = {
      ...resolvedParams,
      headers,
      baseUrl,
      body,
      tls,
      maxRedirections,
      parseAs
    };
    return (0, import_util.request)(method, resolvedPath, options).then((response) => {
      const { body: body2, ...responseWithoutBody } = response;
      (0, import_util.logResponse)(response);
      return {
        ...(0, import_language_common.composeNextState)(state, body2),
        response: responseWithoutBody
      };
    }).catch((err) => {
      (0, import_util.logResponse)(err);
      throw err;
    });
  };
}
function xmlParser(body, script) {
  return (state) => {
    const [resolvedBody] = (0, import_util.expandReferences)(state, body);
    const $ = cheerio.load(resolvedBody);
    (0, import_cheerio_tableparser.default)($);
    if (script) {
      const result = script($);
      try {
        const r = JSON.parse(result);
        return (0, import_language_common.composeNextState)(state, r);
      } catch (e) {
        return (0, import_language_common.composeNextState)(state, { body: result });
      }
    } else {
      return (0, import_language_common.composeNextState)(state, { body: resolvedBody });
    }
  };
}

// src/Adaptor.js
var import_language_common3 = require("@openfn/language-common");
function execute(...operations) {
  const initialState = {
    references: [],
    data: null
  };
  return (state) => {
    return (0, import_language_common2.execute)(...operations)({ ...initialState, ...state });
  };
}
function request2(method, path, options) {
  return request(method, path, options);
}
function get(path, options) {
  return request("GET", path, options);
}
function post(path, data, options) {
  return request("POST", path, { body: data, ...options });
}
function put(path, data, options) {
  return request("PUT", path, { body: data, ...options });
}
function patch(path, data, options) {
  return request("PATCH", path, { body: data, ...options });
}
function del(path, options) {
  return request("DELETE", path, options);
}
function parseXML(data, script) {
  return xmlParser({ body: data }, script);
}

// src/index.js
var src_default = Adaptor_exports;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  alterState,
  arrayToString,
  as,
  chunk,
  combine,
  cursor,
  dataPath,
  dataValue,
  dateFns,
  del,
  each,
  execute,
  field,
  fields,
  fn,
  fnIf,
  get,
  group,
  humanProper,
  lastReferenceValue,
  map,
  merge,
  parseCsv,
  parseXML,
  patch,
  post,
  put,
  request,
  scrubEmojis,
  sourceValue,
  splitKeys,
  toArray,
  util
});
