var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/Adaptor.js
var Adaptor_exports = {};
__export(Adaptor_exports, {
  alterState: () => alterState,
  arrayToString: () => arrayToString,
  as: () => as,
  chunk: () => chunk,
  combine: () => combine,
  cursor: () => cursor,
  dataPath: () => dataPath,
  dataValue: () => dataValue,
  dateFns: () => dateFns,
  del: () => del,
  each: () => each,
  execute: () => execute,
  field: () => field,
  fields: () => fields,
  fn: () => fn,
  fnIf: () => fnIf,
  get: () => get,
  group: () => group,
  humanProper: () => humanProper,
  lastReferenceValue: () => lastReferenceValue,
  map: () => map,
  merge: () => merge,
  parseCsv: () => parseCsv,
  parseXML: () => parseXML,
  patch: () => patch,
  post: () => post,
  put: () => put,
  request: () => request2,
  scrubEmojis: () => scrubEmojis,
  sourceValue: () => sourceValue,
  splitKeys: () => splitKeys,
  toArray: () => toArray
});
import { execute as commonExecute } from "@openfn/language-common";

// src/util.js
var util_exports = {};
__export(util_exports, {
  CONTENT_TYPES: () => CONTENT_TYPES,
  decode: () => decode,
  encode: () => encode,
  getTLSOptions: () => getTLSOptions,
  request: () => request,
  uuid: () => uuid,
  xmlParser: () => xmlParser
});
import { composeNextState } from "@openfn/language-common";
import {
  request as commonRequest,
  makeBasicAuthHeader,
  expandReferences,
  logResponse,
  encode,
  decode,
  uuid
} from "@openfn/language-common/util";
import * as cheerio from "cheerio";
import cheerioTableparser from "cheerio-tableparser";
function addAuth(configuration, headers) {
  if (headers.Authorization) {
    return;
  }
  const { username, password, access_token } = configuration ?? {};
  if (access_token) {
    Object.assign(headers, { Authorization: `Bearer ${access_token}` });
  } else if (username && password) {
    Object.assign(headers, makeBasicAuthHeader(username, password));
  }
}
function encodeFormBody(data) {
  const form = new FormData();
  for (const [key, value] of Object.entries(data)) {
    form.append(key, value);
  }
  return form;
}
function getTLSOptions(state, requestOptions) {
  const { tls: tlsConfig } = state.configuration || {};
  const tls = requestOptions.tls ?? requestOptions.agentOptions ?? tlsConfig;
  return tls;
}
var assertUrl = (pathOrUrl, baseUrl) => {
  if (!baseUrl && pathOrUrl && !/^https?:\/\//.test(pathOrUrl)) {
    const e = new Error("UNEXPECTED_RELATIVE_URL");
    e.code = "UNEXPECTED_RELATIVE_URL";
    e.description = `You passed a relative URL but didn't set baseUrl`;
    e.url = pathOrUrl;
    e.fix = `Set the baseUrl on state.configuration or use an absolute URL, like https://example.com/api/${pathOrUrl}`;
    throw e;
  }
  if (!baseUrl && !pathOrUrl) {
    const e = new Error("NO_URL");
    e.code = "NO_URL";
    e.description = `No URL provided`;
    e.fix = `Make sure to pass a URL string into the request. You may need to set a baseURL on state.configuration.`;
    throw e;
  }
};
var CONTENT_TYPES = {
  xml: "application/xml",
  json: "application/json",
  string: "text/plain"
};
function request(method, path, params) {
  return (state) => {
    var _a;
    const [resolvedPath, resolvedParams = {}] = expandReferences(
      state,
      path,
      params
    );
    let { body, contentType = "json", headers = {}, parseAs } = resolvedParams;
    const contentTypeHeader = Object.keys(headers).find(
      (key) => key.toLowerCase() === "content-type"
    );
    if (contentType === "form") {
      delete headers[contentTypeHeader];
      headers = { ...headers };
      body = encodeFormBody(body);
    } else if (contentTypeHeader) {
      headers = { ...headers };
    } else {
      headers = {
        ...headers,
        "Content-Type": CONTENT_TYPES[contentType] || "application/json"
      };
    }
    const baseUrl = (_a = state.configuration) == null ? void 0 : _a.baseUrl;
    assertUrl(resolvedPath, baseUrl);
    if (baseUrl) {
      addAuth(state.configuration, headers);
    }
    const maxRedirections = resolvedParams.maxRedirections ?? (resolvedParams.followAllRedirects === false ? 0 : 5);
    const tls = getTLSOptions(state, resolvedParams);
    if (resolvedParams.agentOptions) {
      console.warn(
        "WARNING: The `agentOptions` option has been deprecated. Add `tls` to state.configuration instead."
      );
    }
    const options = {
      ...resolvedParams,
      headers,
      baseUrl,
      body,
      tls,
      maxRedirections,
      parseAs
    };
    return commonRequest(method, resolvedPath, options).then((response) => {
      const { body: body2, ...responseWithoutBody } = response;
      logResponse(response);
      return {
        ...composeNextState(state, body2),
        response: responseWithoutBody
      };
    }).catch((err) => {
      logResponse(err);
      throw err;
    });
  };
}
function xmlParser(body, script) {
  return (state) => {
    const [resolvedBody] = expandReferences(state, body);
    const $ = cheerio.load(resolvedBody);
    cheerioTableparser($);
    if (script) {
      const result = script($);
      try {
        const r = JSON.parse(result);
        return composeNextState(state, r);
      } catch (e) {
        return composeNextState(state, { body: result });
      }
    } else {
      return composeNextState(state, { body: resolvedBody });
    }
  };
}

// src/Adaptor.js
import {
  alterState,
  arrayToString,
  as,
  chunk,
  combine,
  cursor,
  dataPath,
  dataValue,
  dateFns,
  each,
  field,
  fields,
  fn,
  fnIf,
  group,
  humanProper,
  lastReferenceValue,
  map,
  merge,
  parseCsv,
  scrubEmojis,
  sourceValue,
  splitKeys,
  toArray
} from "@openfn/language-common";
function execute(...operations) {
  const initialState = {
    references: [],
    data: null
  };
  return (state) => {
    return commonExecute(...operations)({ ...initialState, ...state });
  };
}
function request2(method, path, options) {
  return request(method, path, options);
}
function get(path, options) {
  return request("GET", path, options);
}
function post(path, data, options) {
  return request("POST", path, { body: data, ...options });
}
function put(path, data, options) {
  return request("PUT", path, { body: data, ...options });
}
function patch(path, data, options) {
  return request("PATCH", path, { body: data, ...options });
}
function del(path, options) {
  return request("DELETE", path, options);
}
function parseXML(data, script) {
  return xmlParser({ body: data }, script);
}

// src/index.js
var src_default = Adaptor_exports;
export {
  alterState,
  arrayToString,
  as,
  chunk,
  combine,
  cursor,
  dataPath,
  dataValue,
  dateFns,
  src_default as default,
  del,
  each,
  execute,
  field,
  fields,
  fn,
  fnIf,
  get,
  group,
  humanProper,
  lastReferenceValue,
  map,
  merge,
  parseCsv,
  parseXML,
  patch,
  post,
  put,
  request2 as request,
  scrubEmojis,
  sourceValue,
  splitKeys,
  toArray,
  util_exports as util
};
