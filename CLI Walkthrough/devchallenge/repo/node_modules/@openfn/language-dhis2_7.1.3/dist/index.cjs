var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.js
var src_exports = {};
__export(src_exports, {
  alterState: () => import_language_common3.alterState,
  as: () => import_language_common3.as,
  create: () => create,
  cursor: () => import_language_common3.cursor,
  dataPath: () => import_language_common3.dataPath,
  dataValue: () => import_language_common3.dataValue,
  dateFns: () => import_language_common3.dateFns,
  default: () => src_default,
  destroy: () => destroy,
  each: () => import_language_common3.each,
  execute: () => execute,
  field: () => import_language_common3.field,
  fields: () => import_language_common3.fields,
  fn: () => import_language_common3.fn,
  fnIf: () => import_language_common3.fnIf,
  get: () => get,
  group: () => import_language_common3.group,
  http: () => http_exports,
  lastReferenceValue: () => import_language_common3.lastReferenceValue,
  map: () => import_language_common3.map,
  merge: () => import_language_common3.merge,
  metadata: () => metadata_default,
  sourceValue: () => import_language_common3.sourceValue,
  tracker: () => tracker_exports,
  update: () => update,
  upsert: () => upsert,
  util: () => util_exports
});
module.exports = __toCommonJS(src_exports);

// src/meta/metadata.js
var import_metadata = require("@openfn/language-common/metadata");

// src/meta/helper.js
var import_axios = __toESM(require("axios"), 1);

// src/util.js
var util_exports = {};
__export(util_exports, {
  CONTENT_TYPES: () => CONTENT_TYPES,
  attr: () => attr,
  configureAuth: () => configureAuth,
  dv: () => dv,
  ensureArray: () => ensureArray,
  findAttributeValue: () => findAttributeValue,
  findAttributeValueById: () => findAttributeValueById,
  handleHttpResponse: () => handleHttpResponse,
  handleResponse: () => handleResponse,
  prefixVersionToPath: () => prefixVersionToPath,
  prettyJson: () => prettyJson,
  request: () => request,
  selectId: () => selectId,
  shouldUseNewTracker: () => shouldUseNewTracker
});
var import_language_common = require("@openfn/language-common");
var import_util = require("@openfn/language-common/util");
function shouldUseNewTracker(resourceType) {
  return /^(enrollments|relationships|events|trackedEntities)$/.test(
    resourceType
  );
}
function attr(attribute, value) {
  return { attribute, value };
}
function dv(dataElement, value) {
  return { dataElement, value };
}
function findAttributeValue(trackedEntity, attributeDisplayName) {
  var _a, _b;
  return (_b = (_a = trackedEntity == null ? void 0 : trackedEntity.attributes) == null ? void 0 : _a.find(
    (a) => (a == null ? void 0 : a.displayName.toLowerCase()) == attributeDisplayName.toLowerCase()
  )) == null ? void 0 : _b.value;
}
function findAttributeValueById(trackedEntity, attributeUid) {
  var _a, _b;
  return (_b = (_a = trackedEntity == null ? void 0 : trackedEntity.attributes) == null ? void 0 : _a.find((a) => (a == null ? void 0 : a.attribute) == attributeUid)) == null ? void 0 : _b.value;
}
var CONTENT_TYPES = {
  xml: "application/xml",
  json: "application/json",
  pdf: "application/pdf",
  csv: "application/csv",
  xls: "application/vnd.ms-excel"
};
function selectId(resourceType) {
  switch (resourceType) {
    case "trackedEntityInstances":
      return "trackedEntityInstance";
    default:
      return "id";
  }
}
function handleHttpResponse(result, state) {
  const { body, ...responseWithoutBody } = result;
  const nextState = {
    ...(0, import_language_common.composeNextState)(state, body),
    response: responseWithoutBody
  };
  return nextState;
}
function handleResponse(result, state) {
  const { body } = result;
  const nextState = {
    ...(0, import_language_common.composeNextState)(state, body)
  };
  return nextState;
}
function prettyJson(data) {
  return JSON.stringify(data, null, 2);
}
function ensureArray(data, key) {
  return Array.isArray(data) ? { [key]: data } : { [key]: [data] };
}
function prefixVersionToPath(configuration, options, resourceType, path = null) {
  let { apiVersion } = configuration;
  const urlString = "/" + resourceType;
  if (options == null ? void 0 : options.apiVersion)
    apiVersion = options.apiVersion;
  const apiMessage = apiVersion ? `Using DHIS2 api version ${apiVersion}` : "Using latest available version of the DHIS2 api on this server.";
  console.log(apiMessage);
  const pathSuffix = apiVersion ? `/${apiVersion}${urlString}` : `${urlString}`;
  const urlPath = "/api" + pathSuffix;
  if (path)
    return `${urlPath}/${path}`;
  return urlPath;
}
var configureAuth = (auth, headers = {}) => {
  if ("pat" in auth) {
    Object.assign(headers, {
      Authorization: `ApiToken ${auth.pat}`
    });
  } else if ("password" in auth) {
    Object.assign(headers, (0, import_util.makeBasicAuthHeader)(auth.username, auth.password));
  } else {
    throw new Error(
      "Invalid authorization credentials. Include an pat, username or password in state.configuration"
    );
  }
  return headers;
};
async function request(configuration, requestData) {
  const { hostUrl } = configuration;
  const { method, path, options = {}, data = {} } = requestData;
  const {
    headers = { "content-type": "application/json" },
    query = {},
    parseAs = "json"
  } = options;
  if (options)
    console.log(`with params: `, query);
  const authHeaders = configureAuth(configuration, headers);
  const opts = {
    headers: {
      ...authHeaders,
      ...headers
    },
    query,
    parseAs,
    body: data,
    baseUrl: hostUrl
  };
  return (0, import_util.request)(method, path, opts).then(import_util.logResponse);
}

// src/meta/helper.js
var createHelper = (configuration = {}) => {
  const { username, password, hostUrl } = configuration;
  const get3 = (url) => (0, import_axios.default)({
    url,
    headers: { "Content-Type": "application/json" },
    responseType: "json",
    auth: { username, password },
    params: { paging: false }
  });
  const getResourceTypes = async () => {
    return [
      "dataElementGroups",
      "dataElementGroupSets",
      "dataElements",
      "dataSetNotificationTemplates",
      "dataSets",
      "dataValueSets",
      "enrollments",
      "events",
      "organisationUnitProfile",
      "organisationUnits",
      "programs",
      "trackedEntityAttributes",
      "trackedEntityInstances"
    ];
  };
  const getOrgUnits = async () => {
    const url = prefixVersionToPath(configuration, {}, "organisationUnits");
    const response = await get3(`${hostUrl}${url}`);
    return response.data;
  };
  const getPrograms = () => {
  };
  const getTrackedEntityTypes = async () => {
    const url = prefixVersionToPath(configuration, {}, "trackedEntityTypes");
    const response = await get3(`${hostUrl}${url}`);
    return response.data;
  };
  const getAttributes = async () => {
    const url = prefixVersionToPath(
      configuration,
      {},
      "trackedEntityAttributes"
    );
    const response = await get3(`${hostUrl}${url}`);
    return response.data;
  };
  return {
    getResourceTypes,
    getOrgUnits,
    getTrackedEntityTypes,
    getAttributes
  };
};
var helper_default = createHelper;

// src/meta/metadata.js
var metadata = async (configuration = {}, helper) => {
  var _a, _b;
  if (!helper) {
    helper = helper_default(configuration);
  }
  const children = {};
  const units = await helper.getOrgUnits();
  children.orgUnits = units.organisationUnits.map(
    (unit) => (0, import_metadata.createEntity)(unit.id, "orgUnit", {
      datatype: "string",
      label: unit.displayName
    })
  );
  children.resourceTypes = await helper.getResourceTypes();
  const types = await helper.getTrackedEntityTypes() ?? [];
  children.trackedEntityTypes = ((_a = types.trackedEntityTypes) == null ? void 0 : _a.map(
    (type) => (0, import_metadata.createEntity)(type.id, "trackedEntityType", {
      datatype: "string",
      label: type.displayName
    })
  )) ?? [];
  const attributes = await helper.getAttributes() ?? [];
  children.attributes = ((_b = attributes.trackedEntityAttributes) == null ? void 0 : _b.map(
    (attr2) => (0, import_metadata.createEntity)(attr2.id, "attribute", {
      datatype: "string",
      label: attr2.displayName
    })
  )) ?? [];
  return {
    type: "model",
    name: "dhis2",
    children
  };
};
var metadata_default = metadata;

// src/Adaptor.js
var Adaptor_exports = {};
__export(Adaptor_exports, {
  alterState: () => import_language_common3.alterState,
  as: () => import_language_common3.as,
  create: () => create,
  cursor: () => import_language_common3.cursor,
  dataPath: () => import_language_common3.dataPath,
  dataValue: () => import_language_common3.dataValue,
  dateFns: () => import_language_common3.dateFns,
  destroy: () => destroy,
  each: () => import_language_common3.each,
  execute: () => execute,
  field: () => import_language_common3.field,
  fields: () => import_language_common3.fields,
  fn: () => import_language_common3.fn,
  fnIf: () => import_language_common3.fnIf,
  get: () => get,
  group: () => import_language_common3.group,
  http: () => import_language_common3.http,
  lastReferenceValue: () => import_language_common3.lastReferenceValue,
  map: () => import_language_common3.map,
  merge: () => import_language_common3.merge,
  sourceValue: () => import_language_common3.sourceValue,
  update: () => update,
  upsert: () => upsert
});
var import_language_common2 = require("@openfn/language-common");
var import_util3 = require("@openfn/language-common/util");
var import_language_common3 = require("@openfn/language-common");
function execute(...operations) {
  const initialState = {
    references: [],
    data: null
  };
  return (state) => {
    var _a;
    const version = (_a = state.configuration) == null ? void 0 : _a.apiVersion;
    if (+version < 36) {
      console.warn(
        `WARNING: This adaptor is INCOMPATIBLE with DHIS2 tracker API versions before v36. Some functionality may break. See https://docs.dhis2.org/en/develop/using-the-api/dhis-core-version-master/tracker.html`
      );
    }
    return (0, import_language_common2.execute)(
      configMigrationHelper,
      ...operations
    )({ ...initialState, ...state });
  };
}
function configMigrationHelper(state) {
  const { hostUrl, apiUrl } = state.configuration;
  if (!hostUrl) {
    console.warn(
      "DEPRECATION WARNING: Please migrate instance address from `apiUrl` to `hostUrl`."
    );
    state.configuration.hostUrl = apiUrl;
    return state;
  }
  return state;
}
function create(path, data, params = {}) {
  return async (state) => {
    if (path === "tracker") {
      throw new Error("Invalid resourceType. Use `tracker.import()` instead.");
    }
    const [resolvedPath, resolvedData, resolvedParams] = (0, import_util3.expandReferences)(
      state,
      path,
      data,
      params
    );
    const { configuration } = state;
    let response;
    if (shouldUseNewTracker(resolvedPath)) {
      response = await callNewTracker(
        "create",
        configuration,
        {
          query: resolvedParams
        },
        resolvedPath,
        resolvedData
      );
    } else {
      response = await request(configuration, {
        method: "POST",
        path: prefixVersionToPath(configuration, {}, resolvedPath),
        options: {
          query: resolvedParams
        },
        data: resolvedData
      });
    }
    console.log(`Created ${resolvedPath}`);
    const { location } = response.headers;
    if (location) {
      console.log(`Record available @ ${location}`);
    }
    return handleResponse(response, state);
  };
}
function get(path, params = {}) {
  return async (state) => {
    const [resolvedPath, resolvedParams] = (0, import_util3.expandReferences)(
      state,
      path,
      params
    );
    const response = await request(state.configuration, {
      method: "GET",
      path: prefixVersionToPath(state.configuration, {}, resolvedPath),
      options: { query: resolvedParams }
    });
    console.log(`Retrieved ${resolvedPath}`);
    return handleResponse(response, state);
  };
}
function update(resourceType, path, data, options = {}) {
  return async (state) => {
    console.log(`Preparing update operation...`);
    const [resolvedResourceType, resolvedPath, resolvedData, resolvedOptions] = (0, import_util3.expandReferences)(state, resourceType, path, data, options);
    const { configuration } = state;
    let response;
    if (shouldUseNewTracker(resolvedResourceType)) {
      response = await callNewTracker(
        "update",
        configuration,
        resolvedOptions,
        resolvedResourceType,
        resolvedData
      );
    } else {
      response = await request(configuration, {
        method: "PUT",
        path: prefixVersionToPath(
          configuration,
          resolvedOptions,
          resolvedResourceType,
          resolvedPath
        ),
        options: resolvedOptions,
        data: resolvedData
      });
    }
    console.log(`Updated ${resolvedResourceType} at ${resolvedPath}`);
    return handleResponse(response, state);
  };
}
function upsert(resourceType, query, data, options = {}) {
  return async (state) => {
    const [resolvedResourceType, resolvedOptions, resolvedData, resolvedQuery] = (0, import_util3.expandReferences)(state, resourceType, options, data, query);
    let response;
    const { configuration } = state;
    if (shouldUseNewTracker(resolvedResourceType)) {
      response = await callNewTracker(
        "create_and_update",
        configuration,
        resolvedOptions,
        resolvedResourceType,
        resolvedData
      );
    } else {
      console.log(`Preparing upsert via 'get' then 'create' OR 'update'...`);
      response = await request(configuration, {
        method: "GET",
        path: prefixVersionToPath(
          configuration,
          resolvedOptions,
          resolvedResourceType
        ),
        options: {
          ...resolvedOptions,
          query: {
            ...resolvedQuery
          }
        }
      });
      const resources = response.body[resourceType];
      if (resources.length > 1) {
        (0, import_util3.throwError)(409, {
          description: "Upsert failed: Multiple records found for a non-unique attribute.",
          fix: "Ensure the attribute is unique or modify the request to target a single record.",
          error: "Conflict"
        });
      } else if (resources.length <= 0) {
        console.log(`Preparing create operation...`);
        response = await request(configuration, {
          method: "POST",
          path: prefixVersionToPath(
            configuration,
            resolvedOptions,
            resolvedResourceType
          ),
          options: resolvedOptions,
          data: resolvedData
        });
      } else {
        const path = resources[0][selectId(resourceType)];
        console.log(`Preparing update operation...`);
        response = await request(configuration, {
          method: "PUT",
          path: prefixVersionToPath(
            configuration,
            resolvedOptions,
            resolvedResourceType,
            path
          ),
          options: resolvedOptions,
          data: resolvedData
        });
      }
    }
    console.log(`Performed a "composed upsert" on ${resourceType}`);
    return handleResponse(response, state);
  };
}
function destroy(resourceType, path, data = null, options = {}) {
  return async (state) => {
    console.log("Preparing destroy operation...");
    const [resolvedResourceType, resolvedPath, resolvedData, resolvedOptions] = (0, import_util3.expandReferences)(state, resourceType, path, data, options);
    const { configuration } = state;
    let response;
    if (shouldUseNewTracker(resolvedResourceType)) {
      response = await callNewTracker(
        "delete",
        configuration,
        resolvedOptions,
        resolvedResourceType,
        resolvedData
      );
    } else {
      response = await request(configuration, {
        method: "DELETE",
        path: prefixVersionToPath(
          configuration,
          resolvedOptions,
          resolvedResourceType,
          resolvedPath
        ),
        options: resolvedOptions,
        data: resolvedData
      });
    }
    console.log(`Deleted ${resolvedResourceType} at ${resolvedPath}`);
    return handleResponse(response, state);
  };
}
function callNewTracker(type = "update", configuration, options, resourceType, data = {}) {
  let importStrategy;
  switch (type) {
    case "create":
      importStrategy = "CREATE";
      break;
    case "update":
      importStrategy = "UPDATE";
      break;
    case "delete":
      importStrategy = "DELETE";
      break;
    default:
      importStrategy = "CREATE_AND_UPDATE";
  }
  return request(configuration, {
    method: "POST",
    path: prefixVersionToPath(configuration, options, "tracker"),
    options: {
      ...options,
      query: {
        ...options.query,
        async: false,
        importStrategy
      }
    },
    data: ensureArray(data, resourceType)
  });
}

// src/http.js
var http_exports = {};
__export(http_exports, {
  get: () => get2,
  patch: () => patch,
  post: () => post,
  request: () => request2
});
var import_util5 = require("@openfn/language-common/util");
function get2(path, options = {}) {
  return async (state) => {
    console.log("Preparing get operation...");
    const [resolvedPath, resolvedOptions] = (0, import_util5.expandReferences)(
      state,
      path,
      options
    );
    const { parseAs } = resolvedOptions;
    const response = await request(state.configuration, {
      method: "GET",
      path: prefixVersionToPath(
        state.configuration,
        resolvedOptions,
        resolvedPath
      ),
      options: resolvedOptions
    });
    return handleHttpResponse(response, state);
  };
}
function post(path, data, options = {}) {
  return async (state) => {
    console.log("Preparing post operation...");
    const [resolvedPath, resolvedOptions, resolvedData] = (0, import_util5.expandReferences)(
      state,
      path,
      options,
      data
    );
    const { configuration } = state;
    let response;
    response = await request(configuration, {
      method: "POST",
      path: prefixVersionToPath(
        configuration,
        resolvedOptions,
        resolvedPath
      ),
      options: resolvedOptions,
      data: resolvedData
    });
    return handleHttpResponse(response, state);
  };
}
function patch(resourceType, path, data, options = {}) {
  return async (state) => {
    console.log("Preparing patch operation...");
    const [resolvedResourceType, resolvedPath, resolvedData, resolvedOptions] = (0, import_util5.expandReferences)(state, resourceType, path, data, options);
    const { configuration } = state;
    let response;
    response = await request(configuration, {
      method: "PATCH",
      path: prefixVersionToPath(
        configuration,
        resolvedOptions,
        resolvedResourceType,
        resolvedPath
      ),
      options: resolvedOptions,
      data: resolvedData
    });
    return handleHttpResponse(response, state);
  };
}
function request2(method, path, options = {}) {
  return async (state) => {
    console.log(`Preparing a ${method.toLowerCase()} operation...`);
    const [resolvedMethod, resolvedPath, resolvedOptions = {}] = (0, import_util5.expandReferences)(state, method, path, options);
    const { data } = resolvedOptions;
    const { configuration } = state;
    let response;
    response = await request(configuration, {
      method: resolvedMethod,
      path: prefixVersionToPath(
        configuration,
        resolvedOptions,
        resolvedPath
      ),
      options: resolvedOptions,
      data
    });
    return handleHttpResponse(response, state);
  };
}

// src/tracker.js
var tracker_exports = {};
__export(tracker_exports, {
  export: () => _export,
  import: () => _import
});
var import_util6 = require("@openfn/language-common/util");
function _import(strategy, payload, options = {}) {
  return async (state) => {
    console.log("Preparing tracker import operation...");
    const [resolvedStrategy, resolvedPayload, resolvedOptions] = (0, import_util6.expandReferences)(state, strategy, payload, options);
    const { apiVersion, parseAs, ...query } = resolvedOptions;
    const response = await request(state.configuration, {
      method: "POST",
      path: prefixVersionToPath(
        state.configuration,
        {
          ...resolvedOptions,
          resolvedStrategy
        },
        "tracker"
      ),
      options: {
        apiVersion,
        parseAs,
        query: {
          ...query,
          async: false
        }
      },
      data: resolvedPayload
    });
    return handleHttpResponse(response, state);
  };
}
function _export(path, query, options = {}) {
  return async (state) => {
    console.log("Preparing tracker export operation...");
    const [resolvedPath, resolvedQuery, resolvedOptions] = (0, import_util6.expandReferences)(
      state,
      path,
      query,
      options
    );
    const response = await request(state.configuration, {
      method: "GET",
      path: prefixVersionToPath(
        state.configuration,
        resolvedOptions,
        `tracker/${resolvedPath}`
      ),
      options: {
        ...resolvedOptions,
        query: {
          ...resolvedQuery,
          async: false
        }
      }
    });
    return handleHttpResponse(response, state);
  };
}

// src/index.js
var src_default = Adaptor_exports;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  alterState,
  as,
  create,
  cursor,
  dataPath,
  dataValue,
  dateFns,
  destroy,
  each,
  execute,
  field,
  fields,
  fn,
  fnIf,
  get,
  group,
  http,
  lastReferenceValue,
  map,
  merge,
  metadata,
  sourceValue,
  tracker,
  update,
  upsert,
  util
});
